package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"time"
)

// Factura represents a row from 'CaresoftDB.Factura'.
type Factura struct {
	FacturaCodigo   string         `json:"facturaCodigo"`   // facturaCodigo
	IDCuenta        uint           `json:"idCuenta"`        // idCuenta
	ConsultaCodigo  sql.NullString `json:"consultaCodigo"`  // consultaCodigo
	IDIngreso       sql.NullInt64  `json:"idIngreso"`       // idIngreso
	IDSucursal      uint           `json:"idSucursal"`      // idSucursal
	DocumentoCajero string         `json:"documentoCajero"` // documentoCajero
	MontoSubtotal   float64        `json:"montoSubtotal"`   // montoSubtotal
	MontoTotal      float64        `json:"montoTotal"`      // montoTotal
	Fecha           time.Time      `json:"fecha"`           // fecha
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [Factura] exists in the database.
func (f *Factura) Exists() bool {
	return f._exists
}

// Deleted returns true when the [Factura] has been marked for deletion
// from the database.
func (f *Factura) Deleted() bool {
	return f._deleted
}

// Insert inserts the [Factura] to the database.
func (f *Factura) Insert(ctx context.Context, db DB) error {
	switch {
	case f._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case f._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO CaresoftDB.Factura (` +
		`facturaCodigo, idCuenta, consultaCodigo, idIngreso, idSucursal, documentoCajero, montoSubtotal, montoTotal, fecha` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, f.FacturaCodigo, f.IDCuenta, f.ConsultaCodigo, f.IDIngreso, f.IDSucursal, f.DocumentoCajero, f.MontoSubtotal, f.MontoTotal, f.Fecha)
	if _, err := db.ExecContext(ctx, sqlstr, f.FacturaCodigo, f.IDCuenta, f.ConsultaCodigo, f.IDIngreso, f.IDSucursal, f.DocumentoCajero, f.MontoSubtotal, f.MontoTotal, f.Fecha); err != nil {
		return logerror(err)
	}
	// set exists
	f._exists = true
	return nil
}

// Update updates a [Factura] in the database.
func (f *Factura) Update(ctx context.Context, db DB) error {
	switch {
	case !f._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case f._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE CaresoftDB.Factura SET ` +
		`idCuenta = ?, consultaCodigo = ?, idIngreso = ?, idSucursal = ?, documentoCajero = ?, montoSubtotal = ?, montoTotal = ?, fecha = ? ` +
		`WHERE facturaCodigo = ?`
	// run
	logf(sqlstr, f.IDCuenta, f.ConsultaCodigo, f.IDIngreso, f.IDSucursal, f.DocumentoCajero, f.MontoSubtotal, f.MontoTotal, f.Fecha, f.FacturaCodigo)
	if _, err := db.ExecContext(ctx, sqlstr, f.IDCuenta, f.ConsultaCodigo, f.IDIngreso, f.IDSucursal, f.DocumentoCajero, f.MontoSubtotal, f.MontoTotal, f.Fecha, f.FacturaCodigo); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [Factura] to the database.
func (f *Factura) Save(ctx context.Context, db DB) error {
	if f.Exists() {
		return f.Update(ctx, db)
	}
	return f.Insert(ctx, db)
}

// Upsert performs an upsert for [Factura].
func (f *Factura) Upsert(ctx context.Context, db DB) error {
	switch {
	case f._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO CaresoftDB.Factura (` +
		`facturaCodigo, idCuenta, consultaCodigo, idIngreso, idSucursal, documentoCajero, montoSubtotal, montoTotal, fecha` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`facturaCodigo = VALUES(facturaCodigo), idCuenta = VALUES(idCuenta), consultaCodigo = VALUES(consultaCodigo), idIngreso = VALUES(idIngreso), idSucursal = VALUES(idSucursal), documentoCajero = VALUES(documentoCajero), montoSubtotal = VALUES(montoSubtotal), montoTotal = VALUES(montoTotal), fecha = VALUES(fecha)`
	// run
	logf(sqlstr, f.FacturaCodigo, f.IDCuenta, f.ConsultaCodigo, f.IDIngreso, f.IDSucursal, f.DocumentoCajero, f.MontoSubtotal, f.MontoTotal, f.Fecha)
	if _, err := db.ExecContext(ctx, sqlstr, f.FacturaCodigo, f.IDCuenta, f.ConsultaCodigo, f.IDIngreso, f.IDSucursal, f.DocumentoCajero, f.MontoSubtotal, f.MontoTotal, f.Fecha); err != nil {
		return logerror(err)
	}
	// set exists
	f._exists = true
	return nil
}

// Delete deletes the [Factura] from the database.
func (f *Factura) Delete(ctx context.Context, db DB) error {
	switch {
	case !f._exists: // doesn't exist
		return nil
	case f._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM CaresoftDB.Factura ` +
		`WHERE facturaCodigo = ?`
	// run
	logf(sqlstr, f.FacturaCodigo)
	if _, err := db.ExecContext(ctx, sqlstr, f.FacturaCodigo); err != nil {
		return logerror(err)
	}
	// set deleted
	f._deleted = true
	return nil
}

// FacturaByFacturaCodigo retrieves a row from 'CaresoftDB.Factura' as a [Factura].
//
// Generated from index 'Factura_facturaCodigo_pkey'.
func FacturaByFacturaCodigo(ctx context.Context, db DB, facturaCodigo string) (*Factura, error) {
	// query
	const sqlstr = `SELECT ` +
		`facturaCodigo, idCuenta, consultaCodigo, idIngreso, idSucursal, documentoCajero, montoSubtotal, montoTotal, fecha ` +
		`FROM CaresoftDB.Factura ` +
		`WHERE facturaCodigo = ?`
	// run
	logf(sqlstr, facturaCodigo)
	f := Factura{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, facturaCodigo).Scan(&f.FacturaCodigo, &f.IDCuenta, &f.ConsultaCodigo, &f.IDIngreso, &f.IDSucursal, &f.DocumentoCajero, &f.MontoSubtotal, &f.MontoTotal, &f.Fecha); err != nil {
		return nil, logerror(err)
	}
	return &f, nil
}

// FacturaByConsultaCodigo retrieves a row from 'CaresoftDB.Factura' as a [Factura].
//
// Generated from index 'consultaCodigo'.
func FacturaByConsultaCodigo(ctx context.Context, db DB, consultaCodigo sql.NullString) (*Factura, error) {
	// query
	const sqlstr = `SELECT ` +
		`facturaCodigo, idCuenta, consultaCodigo, idIngreso, idSucursal, documentoCajero, montoSubtotal, montoTotal, fecha ` +
		`FROM CaresoftDB.Factura ` +
		`WHERE consultaCodigo = ?`
	// run
	logf(sqlstr, consultaCodigo)
	f := Factura{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, consultaCodigo).Scan(&f.FacturaCodigo, &f.IDCuenta, &f.ConsultaCodigo, &f.IDIngreso, &f.IDSucursal, &f.DocumentoCajero, &f.MontoSubtotal, &f.MontoTotal, &f.Fecha); err != nil {
		return nil, logerror(err)
	}
	return &f, nil
}

// FacturaByDocumentoCajero retrieves a row from 'CaresoftDB.Factura' as a [Factura].
//
// Generated from index 'documentoCajero'.
func FacturaByDocumentoCajero(ctx context.Context, db DB, documentoCajero string) ([]*Factura, error) {
	// query
	const sqlstr = `SELECT ` +
		`facturaCodigo, idCuenta, consultaCodigo, idIngreso, idSucursal, documentoCajero, montoSubtotal, montoTotal, fecha ` +
		`FROM CaresoftDB.Factura ` +
		`WHERE documentoCajero = ?`
	// run
	logf(sqlstr, documentoCajero)
	rows, err := db.QueryContext(ctx, sqlstr, documentoCajero)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Factura
	for rows.Next() {
		f := Factura{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&f.FacturaCodigo, &f.IDCuenta, &f.ConsultaCodigo, &f.IDIngreso, &f.IDSucursal, &f.DocumentoCajero, &f.MontoSubtotal, &f.MontoTotal, &f.Fecha); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &f)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// FacturaByIDCuenta retrieves a row from 'CaresoftDB.Factura' as a [Factura].
//
// Generated from index 'idCuenta'.
func FacturaByIDCuenta(ctx context.Context, db DB, idCuenta uint) ([]*Factura, error) {
	// query
	const sqlstr = `SELECT ` +
		`facturaCodigo, idCuenta, consultaCodigo, idIngreso, idSucursal, documentoCajero, montoSubtotal, montoTotal, fecha ` +
		`FROM CaresoftDB.Factura ` +
		`WHERE idCuenta = ?`
	// run
	logf(sqlstr, idCuenta)
	rows, err := db.QueryContext(ctx, sqlstr, idCuenta)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Factura
	for rows.Next() {
		f := Factura{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&f.FacturaCodigo, &f.IDCuenta, &f.ConsultaCodigo, &f.IDIngreso, &f.IDSucursal, &f.DocumentoCajero, &f.MontoSubtotal, &f.MontoTotal, &f.Fecha); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &f)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// FacturaByIDIngreso retrieves a row from 'CaresoftDB.Factura' as a [Factura].
//
// Generated from index 'idIngreso'.
func FacturaByIDIngreso(ctx context.Context, db DB, idIngreso sql.NullInt64) (*Factura, error) {
	// query
	const sqlstr = `SELECT ` +
		`facturaCodigo, idCuenta, consultaCodigo, idIngreso, idSucursal, documentoCajero, montoSubtotal, montoTotal, fecha ` +
		`FROM CaresoftDB.Factura ` +
		`WHERE idIngreso = ?`
	// run
	logf(sqlstr, idIngreso)
	f := Factura{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, idIngreso).Scan(&f.FacturaCodigo, &f.IDCuenta, &f.ConsultaCodigo, &f.IDIngreso, &f.IDSucursal, &f.DocumentoCajero, &f.MontoSubtotal, &f.MontoTotal, &f.Fecha); err != nil {
		return nil, logerror(err)
	}
	return &f, nil
}

// FacturaByIDSucursal retrieves a row from 'CaresoftDB.Factura' as a [Factura].
//
// Generated from index 'idSucursal'.
func FacturaByIDSucursal(ctx context.Context, db DB, idsucursal uint) ([]*Factura, error) {
	// query
	const sqlstr = `SELECT ` +
		`facturaCodigo, idCuenta, consultaCodigo, idIngreso, idSucursal, documentoCajero, montoSubtotal, montoTotal, fecha ` +
		`FROM CaresoftDB.Factura ` +
		`WHERE idSucursal = ?`
	// run
	logf(sqlstr, idsucursal)
	rows, err := db.QueryContext(ctx, sqlstr, idsucursal)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Factura
	for rows.Next() {
		f := Factura{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&f.FacturaCodigo, &f.IDCuenta, &f.ConsultaCodigo, &f.IDIngreso, &f.IDSucursal, &f.DocumentoCajero, &f.MontoSubtotal, &f.MontoTotal, &f.Fecha); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &f)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// Cuentum returns the Cuentum associated with the [Factura]'s (IDCuenta).
//
// Generated from foreign key 'Factura_ibfk_1'.
func (f *Factura) Cuentum(ctx context.Context, db DB) (*Cuentum, error) {
	return CuentumByIDCuenta(ctx, db, f.IDCuenta)
}

// Consultum returns the Consultum associated with the [Factura]'s (ConsultaCodigo).
//
// Generated from foreign key 'Factura_ibfk_2'.
func (f *Factura) Consultum(ctx context.Context, db DB) (*Consultum, error) {
	return ConsultumByConsultaCodigo(ctx, db, f.ConsultaCodigo.String)
}

// Ingreso returns the Ingreso associated with the [Factura]'s (IDIngreso).
//
// Generated from foreign key 'Factura_ibfk_3'.
func (f *Factura) Ingreso(ctx context.Context, db DB) (*Ingreso, error) {
	return IngresoByIDIngreso(ctx, db, uint(f.IDIngreso.Int64))
}

// Sucursal returns the Sucursal associated with the [Factura]'s (IDSucursal).
//
// Generated from foreign key 'Factura_ibfk_4'.
func (f *Factura) Sucursal(ctx context.Context, db DB) (*Sucursal, error) {
	return SucursalByIDSucursal(ctx, db, f.IDSucursal)
}

// PerfilUsuario returns the PerfilUsuario associated with the [Factura]'s (DocumentoCajero).
//
// Generated from foreign key 'Factura_ibfk_5'.
func (f *Factura) PerfilUsuario(ctx context.Context, db DB) (*PerfilUsuario, error) {
	return PerfilUsuarioByDocumento(ctx, db, f.DocumentoCajero)
}
