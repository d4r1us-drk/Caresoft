package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// TipoServicio represents a row from 'CaresoftDB.TipoServicio'.
type TipoServicio struct {
	IDTipoServicio uint           `json:"idTipoServicio"` // idTipoServicio
	Nombre         sql.NullString `json:"nombre"`         // nombre
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [TipoServicio] exists in the database.
func (ts *TipoServicio) Exists() bool {
	return ts._exists
}

// Deleted returns true when the [TipoServicio] has been marked for deletion
// from the database.
func (ts *TipoServicio) Deleted() bool {
	return ts._deleted
}

// Insert inserts the [TipoServicio] to the database.
func (ts *TipoServicio) Insert(ctx context.Context, db DB) error {
	switch {
	case ts._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case ts._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO CaresoftDB.TipoServicio (` +
		`nombre` +
		`) VALUES (` +
		`?` +
		`)`
	// run
	logf(sqlstr, ts.Nombre)
	res, err := db.ExecContext(ctx, sqlstr, ts.Nombre)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	ts.IDTipoServicio = uint(id)
	// set exists
	ts._exists = true
	return nil
}

// Update updates a [TipoServicio] in the database.
func (ts *TipoServicio) Update(ctx context.Context, db DB) error {
	switch {
	case !ts._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case ts._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE CaresoftDB.TipoServicio SET ` +
		`nombre = ? ` +
		`WHERE idTipoServicio = ?`
	// run
	logf(sqlstr, ts.Nombre, ts.IDTipoServicio)
	if _, err := db.ExecContext(ctx, sqlstr, ts.Nombre, ts.IDTipoServicio); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [TipoServicio] to the database.
func (ts *TipoServicio) Save(ctx context.Context, db DB) error {
	if ts.Exists() {
		return ts.Update(ctx, db)
	}
	return ts.Insert(ctx, db)
}

// Upsert performs an upsert for [TipoServicio].
func (ts *TipoServicio) Upsert(ctx context.Context, db DB) error {
	switch {
	case ts._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO CaresoftDB.TipoServicio (` +
		`idTipoServicio, nombre` +
		`) VALUES (` +
		`?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`nombre = VALUES(nombre)`
	// run
	logf(sqlstr, ts.IDTipoServicio, ts.Nombre)
	if _, err := db.ExecContext(ctx, sqlstr, ts.IDTipoServicio, ts.Nombre); err != nil {
		return logerror(err)
	}
	// set exists
	ts._exists = true
	return nil
}

// Delete deletes the [TipoServicio] from the database.
func (ts *TipoServicio) Delete(ctx context.Context, db DB) error {
	switch {
	case !ts._exists: // doesn't exist
		return nil
	case ts._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM CaresoftDB.TipoServicio ` +
		`WHERE idTipoServicio = ?`
	// run
	logf(sqlstr, ts.IDTipoServicio)
	if _, err := db.ExecContext(ctx, sqlstr, ts.IDTipoServicio); err != nil {
		return logerror(err)
	}
	// set deleted
	ts._deleted = true
	return nil
}

// TipoServicioByIDTipoServicio retrieves a row from 'CaresoftDB.TipoServicio' as a [TipoServicio].
//
// Generated from index 'TipoServicio_idTipoServicio_pkey'.
func TipoServicioByIDTipoServicio(ctx context.Context, db DB, idTipoServicio uint) (*TipoServicio, error) {
	// query
	const sqlstr = `SELECT ` +
		`idTipoServicio, nombre ` +
		`FROM CaresoftDB.TipoServicio ` +
		`WHERE idTipoServicio = ?`
	// run
	logf(sqlstr, idTipoServicio)
	ts := TipoServicio{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, idTipoServicio).Scan(&ts.IDTipoServicio, &ts.Nombre); err != nil {
		return nil, logerror(err)
	}
	return &ts, nil
}
