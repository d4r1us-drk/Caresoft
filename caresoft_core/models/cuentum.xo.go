package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// Cuentum represents a row from 'CaresoftDB.Cuenta'.
type Cuentum struct {
	IDCuenta         uint    `json:"idCuenta"`         // idCuenta
	DocumentoUsuario string  `json:"documentoUsuario"` // documentoUsuario
	Balance          float64 `json:"balance"`          // balance
	Estado           Estado  `json:"estado"`           // estado
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [Cuentum] exists in the database.
func (c *Cuentum) Exists() bool {
	return c._exists
}

// Deleted returns true when the [Cuentum] has been marked for deletion
// from the database.
func (c *Cuentum) Deleted() bool {
	return c._deleted
}

// Insert inserts the [Cuentum] to the database.
func (c *Cuentum) Insert(ctx context.Context, db DB) error {
	switch {
	case c._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case c._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO CaresoftDB.Cuenta (` +
		`documentoUsuario, balance, estado` +
		`) VALUES (` +
		`?, ?, ?` +
		`)`
	// run
	logf(sqlstr, c.DocumentoUsuario, c.Balance, c.Estado)
	res, err := db.ExecContext(ctx, sqlstr, c.DocumentoUsuario, c.Balance, c.Estado)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	c.IDCuenta = uint(id)
	// set exists
	c._exists = true
	return nil
}

// Update updates a [Cuentum] in the database.
func (c *Cuentum) Update(ctx context.Context, db DB) error {
	switch {
	case !c._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case c._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE CaresoftDB.Cuenta SET ` +
		`documentoUsuario = ?, balance = ?, estado = ? ` +
		`WHERE idCuenta = ?`
	// run
	logf(sqlstr, c.DocumentoUsuario, c.Balance, c.Estado, c.IDCuenta)
	if _, err := db.ExecContext(ctx, sqlstr, c.DocumentoUsuario, c.Balance, c.Estado, c.IDCuenta); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [Cuentum] to the database.
func (c *Cuentum) Save(ctx context.Context, db DB) error {
	if c.Exists() {
		return c.Update(ctx, db)
	}
	return c.Insert(ctx, db)
}

// Upsert performs an upsert for [Cuentum].
func (c *Cuentum) Upsert(ctx context.Context, db DB) error {
	switch {
	case c._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO CaresoftDB.Cuenta (` +
		`idCuenta, documentoUsuario, balance, estado` +
		`) VALUES (` +
		`?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`documentoUsuario = VALUES(documentoUsuario), balance = VALUES(balance), estado = VALUES(estado)`
	// run
	logf(sqlstr, c.IDCuenta, c.DocumentoUsuario, c.Balance, c.Estado)
	if _, err := db.ExecContext(ctx, sqlstr, c.IDCuenta, c.DocumentoUsuario, c.Balance, c.Estado); err != nil {
		return logerror(err)
	}
	// set exists
	c._exists = true
	return nil
}

// Delete deletes the [Cuentum] from the database.
func (c *Cuentum) Delete(ctx context.Context, db DB) error {
	switch {
	case !c._exists: // doesn't exist
		return nil
	case c._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM CaresoftDB.Cuenta ` +
		`WHERE idCuenta = ?`
	// run
	logf(sqlstr, c.IDCuenta)
	if _, err := db.ExecContext(ctx, sqlstr, c.IDCuenta); err != nil {
		return logerror(err)
	}
	// set deleted
	c._deleted = true
	return nil
}

// CuentumByIDCuenta retrieves a row from 'CaresoftDB.Cuenta' as a [Cuentum].
//
// Generated from index 'Cuenta_idCuenta_pkey'.
func CuentumByIDCuenta(ctx context.Context, db DB, idCuenta uint) (*Cuentum, error) {
	// query
	const sqlstr = `SELECT ` +
		`idCuenta, documentoUsuario, balance, estado ` +
		`FROM CaresoftDB.Cuenta ` +
		`WHERE idCuenta = ?`
	// run
	logf(sqlstr, idCuenta)
	c := Cuentum{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, idCuenta).Scan(&c.IDCuenta, &c.DocumentoUsuario, &c.Balance, &c.Estado); err != nil {
		return nil, logerror(err)
	}
	return &c, nil
}

// CuentumByDocumentoUsuario retrieves a row from 'CaresoftDB.Cuenta' as a [Cuentum].
//
// Generated from index 'documentoUsuario'.
func CuentumByDocumentoUsuario(ctx context.Context, db DB, documentoUsuario string) (*Cuentum, error) {
	// query
	const sqlstr = `SELECT ` +
		`idCuenta, documentoUsuario, balance, estado ` +
		`FROM CaresoftDB.Cuenta ` +
		`WHERE documentoUsuario = ?`
	// run
	logf(sqlstr, documentoUsuario)
	c := Cuentum{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, documentoUsuario).Scan(&c.IDCuenta, &c.DocumentoUsuario, &c.Balance, &c.Estado); err != nil {
		return nil, logerror(err)
	}
	return &c, nil
}

// PerfilUsuario returns the PerfilUsuario associated with the [Cuentum]'s (DocumentoUsuario).
//
// Generated from foreign key 'Cuenta_ibfk_1'.
func (c *Cuentum) PerfilUsuario(ctx context.Context, db DB) (*PerfilUsuario, error) {
	return PerfilUsuarioByDocumento(ctx, db, c.DocumentoUsuario)
}
